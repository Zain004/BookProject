<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <!-- Bootstrap 5.3.3 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css"
          rel="stylesheet" integrity="sha384-QWTKZyjpPEjISv5WaRU9OFeRpok6YctnYmDr5pNlyT2bRjXh0JMhjY6hW+ALEwIH"
          crossorigin="anonymous">


</head>
<body>
<!-- Navbar -->
<nav class="navbar navbar-expand-lg navbar-dark bg-dark">
    <a class="navbar-brand" href="#">User Management</a>
    <!-- lager en hamburgermeny-->
    <button class="navbar-toggler" type="button" data-toggle="collapse"
    data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false"
    aria-label="Toggle navigation">
        <span class="navbar-toggler-icon"></span>
    </button>
    <!-- Inneholder selve navigasjonsmenyen-->
    <div class="collapse navbar-collapse" id="navbarNav">
        <ul class="navbar-nav ml-auto">
            <!-- You can add more navigation items here if needed -->
            <li class="nav-item active">
                <a class="nav-link" href="#">
                    User List <span class="visually-hidden">(current)</span></a>
            </li>
        </ul>
    </div>
</nav>

<!-- Main Content Container -->
<div class="container mt-4">
    <div class="row">
        <div class="col">
            <h1 class="mb-4">User List</h1>
            <!-- Loading Indicator -->
            <div id="loadingIndicator" class="text-center mb-3" style="display: none;">
                <div class="spinner-border text-primary" role="status">
                    <!-- Ment for skjermlesere -->
                    <span class="visually-hidden">Loading...</span>
                </div>
                <!-- Dette er den ordentlige teksten som skal vises -->
                <p>Fetching users...</p>
            </div>
            <!-- oppretter en toast-->
            <div class="position-fixed top-0 end-0 p-3" style="z-index: 1050;">
                <div id="toast" class="toast" role="alert" aria-live="assertive" aria-atomic="true" data-bs-delay="5000">
                    <div class="toast-header">
                        <strong class="me-auto">Recipe submission</strong>
                        <button type="button" class="btn-close" data-bs-dismiss="toast" aria-label="close">
                        </button>
                    </div>
                    <div id="toastBody" class="toast-body"> <!-- Dynamically updated content will go here -->
                    </div>
                </div>
            </div>

            <!-- User Table-->
            <div class="table-responsive">
                <table class="table table-striped table bordered">
                    <thead> <!-- Table head -->
                        <tr>
                            <th>ID</th>
                            <th>First Name</th>
                            <th>Last Name</th>
                            <th>Date of Birth</th>
                            <th>Phone</th>
                            <th>Email</th>
                        </tr>
                    </thead>
                    <tbody id="userTableBody">
                        <!-- Brukere vil bli satt inn her -->
                    </tbody>
                </table>
            </div>
            <div id="noUserMessage" class="alert alert-info mt-3" style="display: none" role="alert">
                No users found in the database
            </div>
        </div>
    </div>
</div>
<!-- Bootstrap 5.3.3 JavaScript (bundle with Popper) -->
<script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"
        integrity="sha384-YvpcrYf0tY3lHB60NNkmXc5s9fDVZLESaAA55NDzOxhy9GkcIdslK1eN7N6jIeHz"
        crossorigin="anonymous"></script>
<!-- Axios CDN lenke -->
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<script defer>
    const showToast = (message, isSuccess = true) => {
        const toastElement = document.getElementById('toast');
        const toastBody = toastElement.querySelector('.toast-body');
        toastBody.classList.remove('bg-danger', 'bg-success');
        toastBody.classList.add(isSuccess ? 'bg-success' : 'bg-danger');
        toastBody.textContent = message; // Sett meldingsteksten i toast-body
        const toast = new bootstrap.Toast(toastElement);
        toast.show();
    }

    class LoadingIndicator {
        // Definerer attributer
        static VALID_DISPLAY_TYPES = ['style', 'class'];
        static DEFAULT_OPTIONS = {
            indicatorId: 'loadingIndicator',
            displayType: 'style',
            loadingClass: 'loading-active',
            hiddenClass: 'loading-hidden',
            hideNoUsersDisplay: true,
            timeout: 0,
            targetElement: null
        }
        #indicatorElement
        #timeoutId
        #options // lagres internt

        constructor(options = {}) {
            // 1. Validering og sammenslåing av konfigurasjon
            this.#options = this.#validateAndMergeOptions(options);
            this.#indicatorElement = null;
            this.#timeoutId = null;
            this.#initializeIndicatorElement();
        }
        /*
Når du bruker { ...objekt1, ...objekt2 }, vil:
Alle verdiene fra objekt1 kopieres først.
Alle verdiene fra objekt2 kopieres oppå de første, og overskriver eventuelle duplikater.
         */
        #validateAndMergeOptions(options) {
            const mergedOptions = {
                ...LoadingIndicator.DEFAULT_OPTIONS,
                ...options};
            // sjekker om mergedoptions inneholder VALID_DISPLAY_TYPES
            if (!LoadingIndicator.VALID_DISPLAY_TYPES.includes(mergedOptions.displayType)) {
                throw new Error(`Invalid displayType: ${mergedOptions.displayType}. Must
                be one of: ${LoadingIndicator.VALID_DISPLAY_TYPES.join(', ')}`);
            }
            // Sjekker om targetElement finnes og er et gyldig HTML-element, kaster feil hvis ikke
            if (mergedOptions.targetElement && !(mergedOptions.targetElement instanceof HTMLElement)) {
                throw new TypeError("TargetElement must be an HTMLElement.")
            }
            // Valider timeout, og at den er et tall
            if (mergedOptions.timeout && (typeof mergedOptions.timeout !== 'number' || mergedOptions.timeout < 0)) {
                throw new TypeError("timeout must be a non-negative number.")
            }
            console.debug(mergedOptions);
            return mergedOptions;
        }

        #initializeIndicatorElement() {
            this.#indicatorElement = document.getElementById(this.#options.indicatorId);

            if (!this.#indicatorElement) {
                this.#indicatorElement = this._createIndicatorElement(); // oppretter et nytt objekt og lagrer referansen i #indiactorElement
                const target = this.#options.targetElement || document.body;
                target.appendChild(this.#indicatorElement);
                console.debug("Successfully created loading indicator: " + this.#indicatorElement);
            }
            // sjekker at det faktisk er et HTMLElement
            if (!(this.#indicatorElement instanceof HTMLElement)) {
                throw new Error(`Element with ID '${this.#options.indicatorId}' is not an HTMLElement.`)
            }
        }

        _createIndicatorElement() {
            const element = document.createElement('div');
            element.id = this.#options.indicatorId;
            element.setAttribute('role', 'alert'); // role="alert"
            element.setAttribute('aria-live', 'assertive'); // aria-live="assertive"
            element.setAttribute('aria-busy', false); // aria-busy="false"

            if (this.#options.displayType == 'class') {
                element.classList.add(this.#options.hiddenClass)
            } else {
                element.style.display = 'none';
            }

            const spinner = document.createElement('div');
            spinner.classList.add('spinner');
            element.appendChild(spinner);
            return element;
        }

        show() {
            if (!this.#indicatorElement) {
                console.error("Loading indicator element not initialized.");
                return;
            }
            this.#clearExistingTimeout(); // slett eksisterende timeout før ny kjøres

            if (this.#options.displayType === 'class') {
                this.#indicatorElement.classList.add(this.loadingClass);
                this.#indicatorElement.classList.remove(this.hiddenClass);
            } else {
                this.#indicatorElement.style.display = 'block';
            }

            if (this.#options.hideNoUsersDisplay) {
                if (this.#options.hideNoUsersDisplay) {
                    messageHandler.hideNoUsersMessage(); // antar at hideNoUsersMessage() er definert eller tilgjengelig
                } else {
                    console.warn("hideNoUsersMessage function is not defined. ");
                }
            }
            /*
            Hvis isBusy er true, blir aria-busy satt til 'true', og dette signaliserer til skjermlesere
            og andre tilgjengelighetsteknologier at noe på elementet er
            i ferd med å bli behandlet, som for eksempel at data blir lastet
             */
            this.#setAriaBusy(true);

            if (this.#options.timeout > 0) {
                this.#timeoutId = setTimeout(() => this.hide(), this.#options.timeout);
            }
// timer kalles og skjuler den etter at det ahr gått this.#options.timeout antall sekunder
// er det samme som setTimeout(() => {
// this.hide();
// }, 5000);
        }

        hide() {
            if(!this.#indicatorElement) {
                console.error("Loading indicator element not initialized."); //Bør aldri skje
                return;
            }
            this.#clearExistingTimeout(); // slett eksisterende timout før ny kjøres

            if (this.#options.displayType === 'class') {
                this.#indicatorElement.classList.remove(this.loadingClass);
                this.#indicatorElement.classList.add(this.hiddenClass);
            } else { // Default: style.display
                this.#indicatorElement.style.display = 'none';
            }
            /*
            Hvis isBusy er false, blir aria-busy satt til 'false',
                og dette signaliserer at prosessen er fullført, og elementet er ikke lenger opptatt.
            */
            this.#setAriaBusy(false)
        }
        #setAriaBusy(isBusy) {
            if(this.#indicatorElement && this.#indicatorElement.setAttribute) {
                this.#indicatorElement.setAttribute('aria-busy', isBusy.toString());
            }
        }
        #clearExistingTimeout() {
            if (this.#timeoutId) {
                clearTimeout(this.#timeoutId);
                this.#timeoutId = null;
            }
        }
    }
    class MessageHandler {
        static DEFAULT_OPTIONS = {
            noUsersMessageId: 'noUserMessage'
        }
        #noUsersMessageElement
        #options
        constructor(options = {}) {
            this.#options = {
                ...MessageHandler.DEFAULT_OPTIONS,
                ...options
            };
            this.#noUsersMessageElement = document.getElementById(this.#options.noUsersMessageId);
            this.validateElements();
        }
        validateElements() {
            if (!this.#noUsersMessageElement) {
                throw new Error(`Element with ID '${this.#options.noUsersMessageId}' not found.`);
            }
        }
        displayNoUserMessage = (message = "No users found.") => {
            this.showMessage(this.hideNoUsersMessage());
        }
        showMessage(element, message) {
            if (element) { // Sjekker om elementer er null
                element.textContent = message; // Set the message text
                element.style.display = 'block';
            }
        }
        hideNoUsersMessage() {
            this.hideMessage(this.#noUsersMessageElement);
        }
        hideMessage(element) {
            if (element) {
                element.style.display = 'none';
            }
        }
        clearAndHideMessage(element) {
            if(element) {
                element.textContent = '';
                element.style.display = none;
            }
        }
    }
    const messageHandler = new MessageHandler();
    const loadingIndicator = new LoadingIndicator();

    const fetchUsers = async (retryCount = 0, maxRetries = 3, backOffFactor = 2) => {
        loadingIndicator.show();
        const API_BASE_URL = '/api/users';
        const API_ENDPOINT = '/list';
        const url = `${API_BASE_URL}${API_ENDPOINT}`;
        try {
            const response = await axios.get(url);
            console.log("Fetching users: ")

            if (response.status === 204) {  // Enklest og mest lesbart
                messageHandler.displayNoUserMessage();
                console.log(response)
                console.log("No USers found in DB");
                return;
            }

            if (response.status >= 200 && response.status < 300) { // Mer robust sjekk for suksess
                const apiResponse = response.data; // antar at APIResponse returnerer APIResponse<List<UsersDTO>>
                if (apiResponse.success) {
                    const users = apiResponse.data; // henter ut brukere
                    if (users?.length > 0) {
                        console.debug(users)
                        populateUsersTable(users);
                    } else {
                        // Dette skal *aldri* skje hvis serveren er korrekt (204 er riktig),
                        // men vi legger til en sikkerhetsmekanisme:
                        console.warn("Server returned success with empty data, but not 204 status.");
                        messageHandler.displayNoUserMessage()
                        return;
                    }
                } else // håndterer errors fra global som returnerer false
                    showToast(`API Error: ${apiResponse.message || 'Failed to fetch users'}`, false); // vis API error message
            } else
                showToast(`Unexpected HTTP status: ${response.status}`, false); // behandle andre uforventede statuser
        }
        catch (error) {
            let userFriendlyErrorMessage = "An unexpected error occurred. Please try again later.";
            if (axios.isAxiosError(error)) {
                if(!error.response) {
                    console.error("Network Error: ", error)
                    userFriendlyErrorMessage = "Could not connect to the photo server. Please check your internet connection and try again.";
                } else {
                    const statusCode = error.response.status;
                    console.warn(`API Error ${statusCode}:`, error); // Use warn for API erros, log full error
                    // Bruker en map for feilmeldinger, fordi det er nyere måte
                    const errorMessages = {
                        400: "Invalid search query. Please try again with a different query.", // BAD-REQUEST
                        401: "You are not authorized to view user list.", // UNAUTHORIZED
                        403: "You do not have permission to view user list.", // FORBIDDEN
                        404: "User list resource not found. Please contact support if this issue persists.", // NOT FOUND
                        429: "Too many requests to server. Please wait a few minutes and try again.", // TOO MANY REQUEST
                        500: "The server encountered an error while processing your request. Please try again later." // INTERNAL SERVER ERROR
                    };

                    userFriendlyErrorMessage =  errorMessages[statusCode] || `The server reported an error (${statusCode}). Please try again later.`;
                    /*
                    if (statusCode === 401 || statusCode === 403) {
                        // ekstra håndtering
                    }
                    */
                }
            } else {
                // Non-Axios related errors (e.g., JSON parsing, code errors)
                console.error("Unexpected Error:", error); // Log full error object
            }
// Nettverksfeil - ECONNREFUSED betyr at tilkoblingen til serveren ble avvist.
// ECONNABORTED refererer til en situasjon der tilkoblingen ble avbrutt
// error.code settes av nettverket og ikke av backend
            if (axios.isAxiosError(error) && (error.code === 'ECONNREFUSED' || error.code === 'ECCONNABORTED' ||
                error.response?.status >= 500 || error?.response?.stats === 429)) {
                if (retryCount < maxRetries) {
                    console.warn(`Retry attempt ${retryCount + 1} of ${maxRetries} after error:`, error);
                    const delay = backOffFactor ** retryCount * 1000;
                    await new Promise(resolve => setTimeout(resolve, delay));
                    return fetchUsers(retryCount + 1, maxRetries, backOffFactor);
                } else {

                    console.error("Max retries reached. Error: ", error);
                    userFriendlyErrorMessage = "Failed to fetch users after multiple attempts. " +
                        "Please check your network and try again later.";
                }
                showToast(userFriendlyErrorMessage, false);
            }
        }

        finally {
            loadingIndicator.hide();
        }
    }

    const populateUsersTable = (users) => {
        const tableBody = document.getElementById('userTableBody');
        let htmlRows = ''; // Bygg HTML - stren for alle rader
        if(!users || users.length === 0) {
            tableBody.innerHTML = ''; // Tøm tabellen selv om ingen brukere
            return;
        }
        users.forEach(user => {
            console.log("User: " + JSON.stringify(user))
            // Objekt destrukturering for å hente ur attributer
            const {id, firstName, lastName, dob, phone, email} = user;

            // Bruk template literals for å bygge HTML-raden mer lesbart
            htmlRows += `
                <tr>
                    <td>${id}</td>
                    <td>${firstName}</td>
                    <td>${lastName}</td>
                    <td>${dob}</td>
                    <td>${phone}</td>
                    <td>${email}</td>
                </tr>
            `;
        })
        tableBody.innerHTML = htmlRows;
    }

    document.addEventListener('DOMContentLoaded', () => {
        fetchUsers();
    })
</script>
</body>
</html>